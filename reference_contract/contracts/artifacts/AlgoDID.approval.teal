#pragma version 10

// This TEAL was generated by TEALScript v0.96.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// startUpload(address,uint64,uint64,pay)void
*abi_route_startUpload:
	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (mbrPayment) for startUpload must be a pay transaction
	assert

	// endBoxSize: uint64
	txna ApplicationArgs 3
	btoi

	// numBoxes: uint64
	txna ApplicationArgs 2
	btoi

	// pubKey: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (pubKey) for startUpload must be a address
	assert

	// execute startUpload(address,uint64,uint64,pay)void
	callsub startUpload
	int 1
	return

// startUpload(pubKey: Address, numBoxes: uint64, endBoxSize: uint64, mbrPayment: PayTxn): void
//
//
// Allocate boxes to begin data upload process
//
// @param pubKey The pubkey of the DID
// @param numBoxes The number of boxes that the data will take up
// @param endBoxSize The size of the last box
// @param mbrPayment Payment from the uploader to cover the box MBR
startUpload:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/algo-did.algo.ts:63
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/algo-did.algo.ts:65
	// startBox = this.currentIndex.value
	byte 0x63757272656e74496e646578 // "currentIndex"
	app_global_get
	frame_bury 0 // startBox: uint64

	// contracts/algo-did.algo.ts:66
	// endBox = startBox + numBoxes - 1
	frame_dig 0 // startBox: uint64
	frame_dig -2 // numBoxes: uint64
	+
	int 1
	-
	frame_bury 1 // endBox: uint64

	// contracts/algo-did.algo.ts:68
	// metadata: Metadata = {
	//       start: startBox, end: endBox, status: UPLOADING, endSize: endBoxSize, lastDeleted: 0,
	//     }
	frame_dig 0 // startBox: uint64
	itob
	frame_dig 1 // endBox: uint64
	itob
	concat
	byte 0x00
	concat
	frame_dig -3 // endBoxSize: uint64
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_bury 2 // metadata: Metadata

	// contracts/algo-did.algo.ts:72
	// assert(!this.metadata(pubKey).exists)
	frame_dig -1 // pubKey: Address
	box_len
	swap
	pop
	!
	assert

	// contracts/algo-did.algo.ts:74
	// this.metadata(pubKey).value = metadata
	frame_dig -1 // pubKey: Address
	frame_dig 2 // metadata: Metadata
	box_put

	// contracts/algo-did.algo.ts:76
	// this.currentIndex.value = endBox + 1
	byte 0x63757272656e74496e646578 // "currentIndex"
	frame_dig 1 // endBox: uint64
	int 1
	+
	app_global_put

	// contracts/algo-did.algo.ts:78
	// totalCost = numBoxes * COST_PER_BOX // cost of data boxes
	//     + (numBoxes - 1) * MAX_BOX_SIZE * COST_PER_BYTE // cost of data
	//     + numBoxes * 8 * COST_PER_BYTE // cost of data keys
	//     + endBoxSize * COST_PER_BYTE // cost of last data box
	//     + COST_PER_BOX + (8 + 8 + 1 + 8 + 32 + 8) * COST_PER_BYTE
	frame_dig -2 // numBoxes: uint64
	int 2500
	*
	frame_dig -2 // numBoxes: uint64
	int 1
	-
	int 32768
	*
	int 400
	*
	+
	frame_dig -2 // numBoxes: uint64
	int 8
	*
	int 400
	*
	+
	frame_dig -3 // endBoxSize: uint64
	int 400
	*
	+
	int 2500
	+
	int 26000
	+
	frame_bury 3 // totalCost: uint64

	// contracts/algo-did.algo.ts:84
	// assert(mbrPayment.amount === totalCost)
	frame_dig -4 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // totalCost: uint64
	==
	assert

	// contracts/algo-did.algo.ts:85
	// assert(mbrPayment.receiver === this.app.address)
	frame_dig -4 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert
	retsub

// upload(address,uint64,uint64,byte[])void
*abi_route_upload:
	// data: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// pubKey: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (pubKey) for upload must be a address
	assert

	// execute upload(address,uint64,uint64,byte[])void
	callsub upload
	int 1
	return

// upload(pubKey: Address, boxIndex: uint64, offset: uint64, data: bytes): void
//
//
// Upload data to a specific offset in a box
//
// @param pubKey The pubkey of the DID
// @param boxIndex The index of the box to upload the given chunk of data to
// @param offset The offset within the box to start writing the data
// @param data The data to write
upload:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/algo-did.algo.ts:98
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/algo-did.algo.ts:100
	// metadata = this.metadata(pubKey).value
	frame_dig -1 // pubKey: Address
	frame_bury 0 // storage key//metadata

	// contracts/algo-did.algo.ts:101
	// assert(metadata.status === UPLOADING)
	frame_dig -1 // pubKey: Address
	int 16 // headOffset
	int 1
	box_extract
	btoi
	int 0
	==
	assert

	// contracts/algo-did.algo.ts:102
	// assert(metadata.start <= boxIndex && boxIndex <= metadata.end)
	frame_dig -1 // pubKey: Address
	int 0
	int 8
	box_extract
	btoi
	frame_dig -2 // boxIndex: uint64
	<=
	dup
	bz *skip_and0
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // pubKey: Address
	int 8 // headOffset
	int 8
	box_extract
	btoi
	<=
	&&

*skip_and0:
	assert

	// *if0_condition
	// contracts/algo-did.algo.ts:104
	// offset === 0
	frame_dig -3 // offset: uint64
	int 0
	==
	bz *if0_end

	// *if0_consequent
	// contracts/algo-did.algo.ts:105
	// this.dataBoxes(boxIndex).create(boxIndex === metadata.end ? metadata.endSize : MAX_BOX_SIZE)
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // pubKey: Address
	int 8 // headOffset
	int 8
	box_extract
	btoi
	==
	bz *ternary0_false
	frame_dig -1 // pubKey: Address
	int 17 // headOffset
	int 8
	box_extract
	btoi
	b *ternary0_end

*ternary0_false:
	int 32768

*ternary0_end:
	box_create
	pop

*if0_end:
	// contracts/algo-did.algo.ts:108
	// this.dataBoxes(boxIndex).replace(offset, data)
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig -3 // offset: uint64
	frame_dig -4 // data: bytes
	box_replace
	retsub

// finishUpload(address)void
*abi_route_finishUpload:
	// pubKey: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (pubKey) for finishUpload must be a address
	assert

	// execute finishUpload(address)void
	callsub finishUpload
	int 1
	return

// finishUpload(pubKey: Address): void
//
//
// Mark uploading as false
//
// @param pubKey The address of the DID
finishUpload:
	proto 1 0

	// contracts/algo-did.algo.ts:118
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/algo-did.algo.ts:120
	// this.metadata(pubKey).value.status = READY
	frame_dig -1 // pubKey: Address
	int 16 // headOffset
	byte 0x01
	box_replace
	retsub

// startDelete(address)void
*abi_route_startDelete:
	// pubKey: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (pubKey) for startDelete must be a address
	assert

	// execute startDelete(address)void
	callsub startDelete
	int 1
	return

// startDelete(pubKey: Address): void
//
// Starts the deletion process for the data associated with a DID
//
// @param pubKey The address of the DID
startDelete:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/algo-did.algo.ts:129
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/algo-did.algo.ts:131
	// metadata = this.metadata(pubKey).value
	frame_dig -1 // pubKey: Address
	frame_bury 0 // storage key//metadata

	// contracts/algo-did.algo.ts:132
	// assert(metadata.status === READY)
	frame_dig -1 // pubKey: Address
	int 16 // headOffset
	int 1
	box_extract
	btoi
	int 1
	==
	assert

	// contracts/algo-did.algo.ts:134
	// metadata.status = DELETING
	frame_dig 0 // storage key//metadata
	int 16 // headOffset
	byte 0x02
	box_replace
	retsub

// deleteData(address,uint64)void
*abi_route_deleteData:
	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// pubKey: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (pubKey) for deleteData must be a address
	assert

	// execute deleteData(address,uint64)void
	callsub deleteData
	int 1
	return

// deleteData(pubKey: Address, boxIndex: uint64): void
//
// Deletes a box of data
//
// @param pubKey The address of the DID
// @param boxIndex The index of the box to delete
deleteData:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/algo-did.algo.ts:144
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert

	// contracts/algo-did.algo.ts:146
	// metadata = this.metadata(pubKey).value
	frame_dig -1 // pubKey: Address
	frame_bury 0 // storage key//metadata

	// contracts/algo-did.algo.ts:147
	// assert(metadata.status === DELETING)
	frame_dig -1 // pubKey: Address
	int 16 // headOffset
	int 1
	box_extract
	btoi
	int 2
	==
	assert

	// contracts/algo-did.algo.ts:148
	// assert(metadata.start <= boxIndex && boxIndex <= metadata.end)
	frame_dig -1 // pubKey: Address
	int 0
	int 8
	box_extract
	btoi
	frame_dig -2 // boxIndex: uint64
	<=
	dup
	bz *skip_and1
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // pubKey: Address
	int 8 // headOffset
	int 8
	box_extract
	btoi
	<=
	&&

*skip_and1:
	assert

	// *if1_condition
	// contracts/algo-did.algo.ts:150
	// boxIndex !== metadata.start
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // pubKey: Address
	int 0
	int 8
	box_extract
	btoi
	!=
	bz *if1_end

	// *if1_consequent
	// contracts/algo-did.algo.ts:150
	// assert(metadata.lastDeleted === boxIndex - 1)
	frame_dig -1 // pubKey: Address
	int 25 // headOffset
	int 8
	box_extract
	btoi
	frame_dig -2 // boxIndex: uint64
	int 1
	-
	==
	assert

*if1_end:
	// contracts/algo-did.algo.ts:152
	// preMBR = globals.currentApplicationAddress.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 1 // preMBR: uint64

	// contracts/algo-did.algo.ts:154
	// this.dataBoxes(boxIndex).delete()
	frame_dig -2 // boxIndex: uint64
	itob
	box_del

	// *if2_condition
	// contracts/algo-did.algo.ts:156
	// boxIndex === metadata.end
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // pubKey: Address
	int 8 // headOffset
	int 8
	box_extract
	btoi
	==
	bz *if2_else

	// *if2_consequent
	// contracts/algo-did.algo.ts:156
	// this.metadata(pubKey).delete()
	frame_dig -1 // pubKey: Address
	box_del
	b *if2_end

*if2_else:
	// contracts/algo-did.algo.ts:157
	// metadata.lastDeleted = boxIndex
	int 25 // headOffset
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig 0 // storage key//metadata
	cover 2
	box_replace

*if2_end:
	// contracts/algo-did.algo.ts:159
	// sendPayment({
	//       amount: preMBR - globals.currentApplicationAddress.minBalance,
	//       receiver: this.txn.sender,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/algo-did.algo.ts:160
	// amount: preMBR - globals.currentApplicationAddress.minBalance
	frame_dig 1 // preMBR: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	itxn_field Amount

	// contracts/algo-did.algo.ts:161
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateApplication()void
*abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	int 1
	return

// updateApplication(): void
//
// Allow the contract to be updated by the creator
updateApplication:
	proto 0 0

	// contracts/algo-did.algo.ts:169
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert
	retsub

// dummy()void
*abi_route_dummy:
	// execute dummy()void
	callsub dummy
	int 1
	return

// dummy(): void
//
// Dummy function to add extra box references for deleteData.
// Boxes are 32k, but a single app call can only inlcude enough references to read/write 8k
// at a time. Thus when a box is deleted, we need to add additional dummy calls with box
// references to increase the total read/write budget to 32k.
dummy:
	proto 0 0
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "startUpload(address,uint64,uint64,pay)void"
	method "upload(address,uint64,uint64,byte[])void"
	method "finishUpload(address)void"
	method "startDelete(address)void"
	method "deleteData(address,uint64)void"
	method "dummy()void"
	txna ApplicationArgs 0
	match *abi_route_startUpload *abi_route_upload *abi_route_finishUpload *abi_route_startDelete *abi_route_deleteData *abi_route_dummy

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	method "updateApplication()void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err